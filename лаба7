
#Базовый класс Employee
class Employee:
    def init(self, name, emp_id):
        self.name = name
        self.id = emp_id
    
    def get_info(self):
        return f"Сотрудник: {self.name}, ID: {self.id}"


#Класс Manager
class Manager(Employee):
    def init(self, name, emp_id, department):
        super().init(name, emp_id)
        self.department = department
        self.team = []  # список подчиненных
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, Отдел: {self.department}"
    
    def manage_project(self, project_name):
        return f"Менеджер {self.name} управляет проектом '{project_name}'"
    
    def add_employee(self, employee):
        """Добавление сотрудника в команду"""
        self.team.append(employee)
        return f"Сотрудник {employee.name} добавлен в команду {self.name}"
    
    def get_team_info(self):
        """Информация о всех подчиненных"""
        if not self.team:
            return f"У менеджера {self.name} нет подчиненных"
        
        info = f"Команда менеджера {self.name}:\n"
        for emp in self.team:
            info += f"  - {emp.get_info()}\n"
        return info


#Класс Technician
class Technician(Employee):
    def init(self, name, emp_id, specialization):
        super().init(name, emp_id)
        self.specialization = specialization
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, Специализация: {self.specialization}"
    
    def perform_maintenance(self):
        return f"Техник {self.name} выполняет техническое обслуживание"


#Класс TechManager с множественным наследованием
class TechManager(Manager, Technician):
    def init(self, name, emp_id, department, specialization):
        # Инициализация через Manager (первый родительский класс)
        Manager.init(self, name, emp_id, department)
        # Инициализация атрибута от Technician
        self.specialization = specialization
    
    def get_info(self):
        """Переопределение метода с информацией от обоих классов"""
        return f"Технический менеджер: {self.name}, ID: {self.id}, " \
               f"Отдел: {self.department}, Специализация: {self.specialization}"
    
    def manage_technical_project(self, project_name):
        """Комбинированный метод"""
        return f"Технический менеджер {self.name} управляет техническим проектом '{project_name}'"


#Демонстрация работы классов
if name == "main":
    # Создание объектов
    emp1 = Employee("Иван Иванов", "EMP001")
    mgr1 = Manager("Анна Петрова", "MGR001", "IT")
    tech1 = Technician("Сергей Сидоров", "TECH001", "Сетевое оборудование")
    tech_mgr = TechManager("Ольга Козлова", "TM001", "Разработка", "Python")
    
    #Проверка методов
    print("1. Информация о сотрудниках:")
    print(emp1.get_info())
    print(mgr1.get_info())
    print(tech1.get_info())
    print(tech_mgr.get_info())
    print()
    
    print("2. Работа с командой менеджера:")
    mgr1.add_employee(emp1)
    mgr1.add_employee(tech1)
    print(mgr1.get_team_info())
    print()
    
    print("3. Методы TechManager:")
    print(tech_mgr.manage_project("Разработка ПО"))
    print(tech_mgr.perform_maintenance())
    print(tech_mgr.manage_technical_project("Миграция системы"))
    print()
    
    print("4. Полиморфизм:")
    employees = [emp1, mgr1, tech1, tech_mgr]
    for emp in employees:
        print(emp.get_info())
